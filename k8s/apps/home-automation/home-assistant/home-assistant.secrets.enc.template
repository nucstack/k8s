# yamllint disable
---
apiVersion: v1
kind: Secret
metadata:
  name: home-assistant-helm-values
  namespace: home-automation
stringData:
  values.yaml: |
    addons:
      codeserver:
        git:
          deployKeyBase64: "${HASS_DEPLOY_KEY_B64}"
    env:
      mqtt_server: "mqtt://emqx"
      mqtt_username: "${MQTT_USER1_USERNAME}"
      mqtt_password: "${MQTT_USER1_PASSWORD}"
      hacs_token: "${HASS_HACS_TOKEN}"
      location_lat: "${HASS_LOCATION_LAT}"
      location_long: "${HASS_LOCATION_LONG}"
      alarm_code: "${HASS_ALARM_CODE}"
      db_url: "postgresql://${HASS_POSTGRES_USER}:${HASS_POSTGRES_PASSWORD}@home-assistant-postgresql/${HASS_POSTGRES_DATABASE}"
    postgresql:
      postgresqlUsername: "${HASS_POSTGRES_USER}"
      postgresqlPassword: "${HASS_POSTGRES_PASSWORD}"
      postgresqlDatabase: "${HASS_POSTGRES_DATABASE}"
  home-assistant.cfg: |
    # Must be one of "curl" and "ldapsearch".
    # NOTE:
    # - When choosing "curl", make sure "curl --version | grep ldap" outputs
    #   something. Otherwise, curl was compiled without LDAP support.
    # - When choosing "ldapsearch", make sure the ldapwhoami command is
    #   available as well, as that might be needed in some cases.
    CLIENT="curl"

    # Uncomment to enable debugging to stderr (prints full client output
    # and more).
    DEBUG=1

    # Usernames should be validated using a regular expression to be of
    # a known format. Special characters will be escaped anyway, but it is
    # generally not recommended to allow more than necessary.
    # This pattern is set by default. In your config file, you can either
    # overwrite it with a different one or use "unset USERNAME_PATTERN" to
    # disable validation completely.
    USERNAME_PATTERN='^[a-z|A-Z|0-9|_|-|.]+$'

    # Adapt to your needs.
    SERVER="ldaps://${LDAP_SERVER}"
    # Will try binding as this user.
    # ldap_dn_escape escapes special characters in strings to make them
    # usable within LDAP DN components.
    USERDN="uid=$(ldap_dn_escape "$username"),cn=users,${LDAP_ROOT}"

    # If you want to take additional checks like requiring group memberships
    # or fetch specific user attributes, you can execute a custom search, which
    # has to return exactly one result in order for authentication to succeed.
    # Uncomment the following lines to enable search query execution.
    BASEDN="${LDAP_ROOT}"
    #SCOPE="base"
    #FILTER="(&(objectClass=person)(memberOf=cn=some-group,ou=groups,dc=example,dc=com))"
    # Space-separated list of additional LDAP attributes to query.
    # You could process them in your own on_auth_success hook.
    #ATTRS="cn"

    # When the timeout (in seconds) is exceeded (e.g. due to slow networking),
    # authentication fails.
    TIMEOUT=3

    # Uncomment to have the value of cn be set as user's friendly name in
    # Home Assistant. This only works if you also enable searching (BASEDN,
    # SCOPE and FILTER).
    #NAME_ATTR="cn"
    #ATTRS="$ATTRS $NAME_ATTR"

    on_auth_success() {
      # print the meta entries for use in HA
      if [ ! -z "$NAME_ATTR" ]; then
        name=$(echo "$output" | sed -nr "s/^\s*$NAME_ATTR:\s*(.+)\s*\$/\1/Ip")
        [ -z "$name" ] || echo "name=$name"
      fi
    }
  ldap.sh: |
    #!/bin/sh

    # Log messages to stderr.
    log() {
      echo "$1" >&2
    }


    # Escape string to be safely usable in LDAP DN components and URIs.
    # https://ldapwiki.com/wiki/DN%20Escape%20Values
    ldap_dn_escape() {
      escaped=$(echo "$1" | sed -r \
        -e 's/[,\\#+<>;"=/?]/\\\0/g' \
        -e 's/^ (.*)$/\\ \1/' \
        -e 's/^(.*) $/\1\\ /' \
      )
      [ -z "$DEBUG" ] || log "Escaped '$1' to '$escaped'."
      echo "$escaped"
    }


    # The different client implementations.
    ldap_auth_curl() {
      [ -z "$DEBUG" ] || verbose="-v"
      attrs=$(echo "$ATTRS" | sed "s/ /,/g")
      output=$(curl $verbose -s -m "$TIMEOUT" -u "$USERDN:$password" \
        "$SERVER/$BASEDN?dn,$attrs?$SCOPE?$FILTER")
      [ $? -ne 0 ] && return 1
      return 0
    }

    ldap_auth_ldapsearch() {
      common_opts="-o nettimeout=$TIMEOUT -H $SERVER -x"
      [ -z "$DEBUG" ] || common_opts="-v $common_opts"
      if [ -z "$BASEDN" ]; then
        output=$(ldapwhoami $common_opts -D "$USERDN" -w "$password")
      else
        output=$(ldapsearch $common_opts -LLL \
          -D "$USERDN" -w "$password" \
          -s "$SCOPE" -b "$BASEDN" "$FILTER" dn $ATTRS)
      fi
      [ $? -ne 0 ] && return 1
      return 0
    }


    # Source the config file.
    if [ -z "$1" ]; then
      log "Usage: ldap-auth.sh <config-file>"
      exit 2
    fi
    CONFIG_FILE=$(realpath "$1")
    if [ ! -e "$CONFIG_FILE" ]; then
      log "'$CONFIG_FILE': not found"
      exit 2
    elif [ ! -f "$CONFIG_FILE" ]; then
      log "'$CONFIG_FILE': not a file"
      exit 2
    elif [ ! -r "$CONFIG_FILE" ]; then
      log "'$CONFIG_FILE': no read permission"
      exit 2
    fi
    . "$CONFIG_FILE"

    # Validate config.
    err=0
    if [ -z "$SERVER" ] || [ -z "$USERDN" ]; then
      log "SERVER and USERDN need to be configured."
      err=1
    fi
    if [ -z "$TIMEOUT" ]; then
      log "TIMEOUT needs to be configured."
      err=1
    fi
    if [ ! -z "$BASEDN" ]; then
      if [ -z "$SCOPE" ] || [ -z "$FILTER" ]; then
        log "BASEDN, SCOPE and FILTER may only be configured together."
        err=1
      fi
    elif [ ! -z "$ATTRS" ]; then
      log "Configuring ATTRS only makes sense when enabling searching."
      err=1
    fi

    # Check username and password are present and not malformed.
    if [ -z "$username" ] || [ -z "$password" ]; then
      log "Need username and password environment variables."
      err=1
    elif [ ! -z "$USERNAME_PATTERN" ]; then
      username_match=$(echo "$username" | sed -r "s/$USERNAME_PATTERN/x/")
      if [ "$username_match" != "x" ]; then
        log "Username '$username' has an invalid format."
        err=1
      fi
    fi

    [ $err -ne 0 ] && exit 2

    # Do the authentication.
    case "$CLIENT" in
      "curl")
        ldap_auth_curl
        ;;
      "ldapsearch")
        ldap_auth_ldapsearch
        ;;
      *)
        log "Unsupported client '$CLIENT', revise the configuration."
        exit 2
        ;;
    esac

    result=$?

    entries=0
    if [ $result -eq 0 ] && [ ! -z "$BASEDN" ]; then
      entries=$(echo "$output" | grep -cie '^dn\s*:')
      [ "$entries" != "1" ] && result=1
    fi

    if [ ! -z "$DEBUG" ]; then
      cat >&2 <<-EOF
        Result: $result
        Number of entries: $entries
        Client output:
        $output
        EOF
    fi

    if [ $result -ne 0 ]; then
      log "User '$username' failed to authenticate."
      type on_auth_failure > /dev/null && on_auth_failure
      exit 1
    fi

    log "User '$username' authenticated successfully."
    type on_auth_success > /dev/null && on_auth_success
    exit 0
